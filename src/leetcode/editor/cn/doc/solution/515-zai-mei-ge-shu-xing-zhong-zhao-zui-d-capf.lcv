**这道题和102题基本是一样的，就是求每一层的最大值，因此遍历时直接不断比较大小即可。**

纯新手刚刚开始刷题，为了让自己更好掌握，附带特别详细的代码解释，主要是用来说服自己，请大家指导，也是为了加深印象，之前做的题看了题解觉得明白了，过几天就都忘记了，所以想着记录下来~都是自己写的注释，有问题麻烦大家指出~厉害的人不要笑话我写这么细，完全刚开始~争取把每道题都自己弄懂~加油~

### 解题思路

题目是对二叉树进行层序遍历，首先想到应该用递归，写了半天怎么写都觉得好奇怪，感觉用广度优先搜索能简单一些，于是换了思路，等下再去研究递归。

因为是层序遍历，每一层的左节点右节点不停的遍历，感觉和队列的先进先出很像，所以考虑用队列实现。关键在于队列的先进先出顺序，能够保证每一层的元素都遍历到。先把根节点放入队列，然后把它弹出来，把弹出来的元素的左节点右节点再放入队列中，此时在队列的后面，不影响队列前面的顺序。不断的重复，就实现了题目中所说的层序遍历。

### 代码

* python3

```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root: #首先排除特殊情况，如果root为空，则返回[]
            return []
        res = [] #初始化一个结果数组
        q = collections.deque() #初始化一个队列
        q.append(root) #首先将根节点放入队列中
        while q: #因为类似于是对二叉树进行层序遍历，因此需要循环到队列为空的时候
            ans = -2 ** 31 #因为要返回每一层的最大值，因此需要设置一个过渡参数，注意这里要给定最小的值，可能有负数的出现
            m = len(q) #记录一下当前时刻队列的长度，即一层树的节点数目，目的在于返回值是每一层的最大值，因此需要利用for循环语句
            for i in range(m): #按照队列的当前长度进行遍历
                tmp = q.popleft() #首先将队列中的第一个元素弹出
                ans = max(ans, tmp.val) #将新弹出的节点的元素与原来的最大值进行比较，保留新的最大值
                if tmp.left: #如果当前节点的左子树不为空，则将它放入队列中
                    q.append(tmp.left)
                if tmp.right: #如果当前节点的右子树不为空，则将它放入队列中
                    q.append(tmp.right)
            res.append(ans) #当前层遍历结束，将本层的最大值放入最后的返回结果参数中
        return res


```

